package com.cppib.fscvaluation.service;

import com.cppib.fscvaluation.domain.*;
import com.cppib.fscvaluation.repository.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;

import javax.transaction.Transactional;
import java.sql.Date;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.text.DecimalFormat;

@Service
public class AccelexCostFVServiceImpl implements AccelexCostFVService {
    private final Logger logger = LoggerFactory.getLogger(AccelexCostFVServiceImpl.class);

    protected final static DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    @Value("${ROMEserver.url}")
    private String ROMEServerUrl;
    private String RomePath = "/FinancialLedgerDataService/rest/request/stream/PISubledgerDataExtract";

    @Value("${Email.defaultFVChangeEmail}")
    private String defaultEmail;

    @Value("${Email.supportEmail}")
    private String supportEmail;

    @Value("${env_level}")
    private String envLevel;

    private final static List<String> componentList = Arrays.asList("GP Carrying value of fund", "Total Assets", "Total Investments", "Total Liabilities", "Accrued Carried Interest", "Accrued Management Fees",
            "Foreign Exchange Gain/Loss", "Fund Expenses", "Lines of Credit", "Lines of Credit - Interest Expense");

    @Autowired
    Accelex_CostFVRepository accelexCostFVRepository;

    @Autowired
    FSC_Valuation_GP_Holdings_TotalRepository fsc_valuation_gp_holdings_totalRepository;

    @Autowired
    FSC_Valuation_TrackerRepository fsc_valuation_trackerRepository;

    @Autowired
    FSC_Valuation_UserRepository fsc_valuation_userRepository;

    @Autowired
    FSC_Valuation_DotCoComponentRepository fsc_Valuation_dotCoComponentRepository;

    @Autowired
    EmailService emailService;

    @Autowired
    DataService dataService;


    public List<Accelex_CostFV> findAll() {
        List<Accelex_CostFV> accelex_costFV = new ArrayList<Accelex_CostFV>();
        accelexCostFVRepository.findAll().forEach(accelex_costFV::add);
        logger.info("e" + accelex_costFV.toString());
        return accelex_costFV;
    }


    public List<Accelex_CostFV> getdealsByValuationdate(Date valuationquarter) {
        List<Accelex_CostFV> accelex_costFV = new ArrayList<Accelex_CostFV>();
        accelexCostFVRepository.finddealsbyvaluationdate(valuationquarter).forEach(accelex_costFV::add);
        logger.info("e" + accelex_costFV.toString());
        return accelex_costFV;
    }

    public Accelex_CostFV getAccelexCostFV(Date valuationDate, Integer dealID, Integer specificPositionID) {
        Accelex_CostFV_ID id = new Accelex_CostFV_ID();
        id.setValuationDate(valuationDate);
        id.setDealID(dealID);
        id.setSpecificPositionID(specificPositionID);

        Optional<Accelex_CostFV> optionalAccelexCostFV = accelexCostFVRepository.findById(id);
        if (optionalAccelexCostFV.isPresent()) {
            return optionalAccelexCostFV.get();
        } else {
            // handle the case where the Accelex_CostFV is not found
            return null; // or throw an exception, depending on your use case
        }
//        return accelexCostFVRepository.findOne(id);
    }

    @Transactional
    public void processAccelexCostFv(List<Accelex_CostFV> fvCosts, String costFVFileName) {
        Accelex_CostFV dotCompany = fvCosts.get(0);
        String scdID = dotCompany.getScdID();
        Date valuationDate = dotCompany.getValuationDate();
        // Update the tracker status
        ValuationSCDID scdIDValuationDate = new ValuationSCDID();
        scdIDValuationDate.SCDID = scdID;
        scdIDValuationDate.ValuationDate = valuationDate;
        FSC_Valuation_Tracker oneTracker = fsc_valuation_trackerRepository.findById(scdIDValuationDate).get();
        logger.info("Looking for tracker: " + dotCompany.getDealName() + "date: " + valuationDate);
        if (oneTracker != null) {
            Map<String, Object[]> missingPositionsInFile = verifyPositions(fvCosts, valuationDate);
            if(oneTracker.getDealID() == null) {
                logger.info("Tracker DealID is Null");
                oneTracker.setDealID(dotCompany.getDealID());
                logger.info("Tracker DealID changed from Null to: " + dotCompany.getDealID());
                fsc_valuation_trackerRepository.save(oneTracker);
                logger.info("DealID Successfully updated in the tracker table!");
            }
            logger.info("Found tracker: " + dotCompany.getDealName() + " date: " + valuationDate);
            if (oneTracker.getCommitmentPercentage() == null) {
                updateTrackerCommitmentPercentageFromRome(scdID, oneTracker);
            }
            if(oneTracker.getDocoPositionID() == null) {
                updateTrackerDocoPositionIDFromRome(scdID,oneTracker);
            }

            boolean isInitialLoad = false;
            List<FSC_Valuation_GP_Holdings_Total> currentQuarterHoldings = fsc_valuation_gp_holdings_totalRepository.getGPPositionsBySCDID(valuationDate, scdID);
            if (currentQuarterHoldings.size() == 0) {
                // Get prev quarter holdings and update
                // FV cost default
                logger.info("Current quarter holdings data is not present. Getting holdings from last quarter");
                isInitialLoad = true;
                Date lastQuarterEnd = Date.valueOf(getLastQuarterEnd(valuationDate.toString()));
                List<FSC_Valuation_GP_Holdings_Total> previousQuarterHoldings = fsc_valuation_gp_holdings_totalRepository.getGPPositionsBySCDID(lastQuarterEnd, scdID);
                if (!previousQuarterHoldings.isEmpty()) {
                    insertPreviousQuarterHoldingsToCurrentQuarter(previousQuarterHoldings, valuationDate);
                    logger.info("Loaded previous quarter data into current quarter");
                } else {
                    logger.info("Previous quarter holdings data is also not present. Getting data from Investran");
                    insertHoldingsRecordForCurrentQuarterFromRome(scdID, valuationDate);
                    logger.info("Loaded Investran data into current quarter");
                }
            }

            List<Map<String, Object[]>> loadStats;
            loadStats = saveAccelexCostFV(fvCosts, BigDecimal.valueOf(dotCompany.getSpecificPositionID()), oneTracker, costFVFileName);
            Map<String, Object[]> loadHistory = loadStats.get(0);
            Map<String, Object[]> newPositions = loadStats.get(1);
            if (missingPositionsInFile.size() > 0) {
                String exceptionMessage = "Position ID missing from csv file";
                String emailBody = createNewOrMissingPositionExceptionEmailBody(scdID, dotCompany.getDealName(), missingPositionsInFile, costFVFileName, exceptionMessage);
                String subject = envLevel + ": " + "Error occurred when loading Accelex FV&Cost file: " + costFVFileName;
                sendNotificationEmail(defaultEmail,"",emailBody,subject);
            }
            if (!isInitialLoad && loadHistory.size() > 0) {
                String emailBody = createCostFVEmailBody(scdID, dotCompany.getDealName(), loadHistory);
                String subject = "<" + envLevel + ">" + "Accelex FundCost & FundFairValue Valuation Change for " + dotCompany.getDealName();
                String toList = getPreparerReviewerEmail(oneTracker.getPreparer(), oneTracker.getReviewer());
                sendNotificationEmail(toList, "", emailBody, subject);
            }
            if (!isInitialLoad && newPositions.size() > 0) {
                String exceptionMessage = "Position ID in csv not found in Valuation GUI. Entity Reference data could be incorrect or missing from Investran Static Data file.";
                String emailBody = createNewOrMissingPositionExceptionEmailBody(scdID, dotCompany.getDealName(), newPositions, costFVFileName, exceptionMessage);
                String subject = envLevel + ": " + "Error occurred when loading Accelex FV & Cost File: " + costFVFileName;
                sendNotificationEmail(defaultEmail, "",emailBody, subject);
            }

            // check if record exists in [qfv].[FSC_Valuation_DotCoComponent]
            boolean isDotCoComponentFound = false;
            List<FSC_Valuation_DotCoComponent> list_FSC_Valuation_DotCoComponent = fsc_Valuation_dotCoComponentRepository.getDocoPositionsBySCDID(valuationDate, scdID);
            if (list_FSC_Valuation_DotCoComponent != null) {
                for (FSC_Valuation_DotCoComponent fsc_Valuation_DotCoComponent : list_FSC_Valuation_DotCoComponent) {
                    String positionName = fsc_Valuation_DotCoComponent.getComponentName();
                    if (positionName.equals("GP Carrying value of fund")) {
                        isDotCoComponentFound = true;
                        break;
                    }
                }
            }

            if (!isDotCoComponentFound) {
                // record NOT exists in [qfv].[FSC_Valuation_DotCoComponent]
                // insert into [qfv].[FSC_Valuation_DotCoComponent] with new ValuationDate
                logger.info("Inserting default DotCoComponent record in FSC_Valuation_DotCoComponent: {} - {}", scdID, valuationDate);
                insertDefaultDotCoComponent(valuationDate, fvCosts.get(0).getDealID(), scdID);
            }
        } else {
            logger.info("Tracker record for valuation date: " + scdIDValuationDate.ValuationDate + " not found");
            logger.info("Nothing was loaded!");

            // send email notification to roll up GPDC to current quarter
            String toList = defaultEmail;
            String ccList = "";
            String subject = "<" + envLevel + ">" + "Accelex FV & Cost - Tracker Record Missing for " + scdID + " - " + valuationDate;
            String emailBody = "<p> Hi Team, <br> <br>"
                    + "Tracker record is missing for " + scdID + " - " + valuationDate
                    + ". Please roll up GPDC FSC Valuation to current quarter: " + valuationDate + "</p>";
            try {
                emailService.sendEmailbyBody(toList, ccList, subject, emailBody);
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }

    }

    private void insertPreviousQuarterHoldingsToCurrentQuarter(List<FSC_Valuation_GP_Holdings_Total> previousQuarterHoldings, Date currentQuarterDate) {
        for (FSC_Valuation_GP_Holdings_Total prevHolding : previousQuarterHoldings) {
            ValuationDealPositionGLDateEffectiveDate newID = new ValuationDealPositionGLDateEffectiveDate();
            newID.PositionID = prevHolding.getID().PositionID;
            newID.DealID = prevHolding.getID().DealID;
            newID.ValuationDate = currentQuarterDate;
            newID.GLDate = currentQuarterDate;
            newID.EffectiveDate = currentQuarterDate;

            Float percentage = ((prevHolding.getPercentage() == null) ? 0 : prevHolding.getPercentage());
            FSC_Valuation_GP_Holdings_Total newHolding = new FSC_Valuation_GP_Holdings_Total();
            newHolding.setID(newID);
            newHolding.setSCDID(prevHolding.getSCDID());
            newHolding.setPositionName(prevHolding.getPositionName());
            newHolding.setFundFairValue(new BigDecimal("0.0"));
            newHolding.setFundCost(new BigDecimal("0.0"));
            newHolding.setPercentage(percentage);
            newHolding.setCppibCost(new BigDecimal("0.0"));
            newHolding.setCppibFairValue(new BigDecimal("0.0"));
            newHolding.setDataSource("Auto");
            fsc_valuation_gp_holdings_totalRepository.save(newHolding);
        }
    }

    @Transactional
    public List<Map<String, Object[]>> saveAccelexCostFV(List<Accelex_CostFV> fvCosts, BigDecimal dotCompanyPositionId, FSC_Valuation_Tracker oneTracker, String costFVFileName) {
        List<Map<String, Object[]>> loadStats = new ArrayList<>();
        Map<String, Object[]> loadHistory = new HashMap<>();
        Map<String, Object[]> newPosition = new HashMap<>();
        Map<String, Object[]> noPosition = new HashMap<>();
        for(Accelex_CostFV accelex_costFV: fvCosts) {
            accelexCostFVRepository.save(accelex_costFV);
            String valuationDate = accelex_costFV.getValuationDate().toString();  //get from "accelex_costFV"
            Integer dealID = accelex_costFV.getDealID();
            String scdID = accelex_costFV.getScdID();
            BigDecimal specificPositionID = new BigDecimal(accelex_costFV.getSpecificPositionID());
            //insert into [GPDC].[qfv].[FSC_Valuation_GP_Holdings_Total]
            ValuationDealPositionGLDateEffectiveDate id = getSearchID(valuationDate, specificPositionID, dealID);


            //check if there is an record for a given ValuationDate, DealID, PositionID,GLDate, EffectiveDate
            FSC_Valuation_GP_Holdings_Total valuationFVCostbyID = fsc_valuation_gp_holdings_totalRepository.findById(id).get();
            if (valuationFVCostbyID == null) {
                logger.info("Position: " + accelex_costFV.getPositionName() + " not found. Creating a new holdings record");
                // New position and was not present from the previous quarter
                ValuationDealPositionGLDateEffectiveDate dotCompanyID = getSearchID(valuationDate, dotCompanyPositionId, accelex_costFV.getDealID());
                FSC_Valuation_GP_Holdings_Total dotCompanyHolding = fsc_valuation_gp_holdings_totalRepository.findById(dotCompanyID).get();

                FSC_Valuation_GP_Holdings_Total fscValuationGpHoldingsTotal = new FSC_Valuation_GP_Holdings_Total();
                fscValuationGpHoldingsTotal.setID(id);
                fscValuationGpHoldingsTotal.setSCDID(scdID);
                fscValuationGpHoldingsTotal.setPositionName(getPositionNameByPositionIDFromRome(scdID, specificPositionID, costFVFileName));
                fscValuationGpHoldingsTotal.setFundFairValue(accelex_costFV.getFundFairValue());
                fscValuationGpHoldingsTotal.setFundCost(accelex_costFV.getFundCost());
                fscValuationGpHoldingsTotal.setPercentage((dotCompanyHolding != null && dotCompanyHolding.getPercentage() != null) ? dotCompanyHolding.getPercentage() : 0);
                fscValuationGpHoldingsTotal.setCppibCost(new BigDecimal(0.0));
                fscValuationGpHoldingsTotal.setCppibFairValue(new BigDecimal(0.0));
                fscValuationGpHoldingsTotal.setDataSource("Auto");
                fsc_valuation_gp_holdings_totalRepository.save(fscValuationGpHoldingsTotal);
                logger.info("Successfully inserted " + accelex_costFV.getPositionName() + " in holdings table");

                oneTracker.setStatus("Data Preparation In Progress");
                fsc_valuation_trackerRepository.save(oneTracker);
                newPosition.put(accelex_costFV.getPositionName(), new Object[] {accelex_costFV.getSpecificPositionID().toString()});
            } else {
                logger.info("Found the GP Holding for position ID: " + specificPositionID);
                BigDecimal accelex_fv = accelex_costFV.getFundFairValue();
                BigDecimal accelex_cost = accelex_costFV.getFundCost();
                logger.info(accelex_costFV.getDealName() + " and " + accelex_costFV.getPositionName() + " accelex_fv = " + accelex_fv.toString());
                logger.info(accelex_costFV.getDealName() + " and " + accelex_costFV.getPositionName() + " accelex_cost = " + accelex_cost.toString());

                BigDecimal valuation_fv = valuationFVCostbyID.getFundFairValue();
                BigDecimal valuation_cost = valuationFVCostbyID.getFundCost();
                logger.info(accelex_costFV.getDealName() + " and " + accelex_costFV.getPositionName() + " valuation_fv = " + valuation_fv.toString());
                logger.info(accelex_costFV.getDealName() + " and " + accelex_costFV.getPositionName() + " valuation_cost = " + valuation_cost.toString());

                boolean isInitialLoad = valuation_fv.compareTo(BigDecimal.ZERO) == 0 && valuation_cost.compareTo(BigDecimal.ZERO) == 0;
                if (accelex_fv.compareTo(valuation_fv) != 0 || accelex_cost.compareTo(valuation_cost) != 0) {
                    logger.info("accelex_fv or cost is different for " + accelex_costFV.getDealName() + " and " + accelex_costFV.getPositionName());
                    valuationFVCostbyID.setFundFairValue(accelex_costFV.getFundFairValue());
                    valuationFVCostbyID.setFundCost(accelex_costFV.getFundCost());
                    valuationFVCostbyID.setDataSource("Auto");
                    fsc_valuation_gp_holdings_totalRepository.save(valuationFVCostbyID);
                    oneTracker.setStatus("Data Preparation In Progress");
                    fsc_valuation_trackerRepository.save(oneTracker);
                    logger.info("Successfully updated fv value and cost for position: " + accelex_costFV.getPositionName());

                    if (!isInitialLoad) {
                        loadHistory.put(accelex_costFV.getPositionName(), new Object[]{valuation_fv, valuation_cost, accelex_costFV.getFundFairValue(), accelex_costFV.getFundCost()});
                    }
                }

            }
        }
        loadStats.add(0,loadHistory);
        loadStats.add(1, newPosition);
        return loadStats;
    }

    private ValuationDealPositionGLDateEffectiveDate getSearchID(String valuationDate, BigDecimal positionID, Integer dealID) {
        ValuationDealPositionGLDateEffectiveDate id = new ValuationDealPositionGLDateEffectiveDate();
        id.ValuationDate = Date.valueOf(valuationDate);
        id.DealID = dealID;
        id.PositionID = positionID;
        id.GLDate = Date.valueOf(valuationDate);
        id.EffectiveDate = Date.valueOf(valuationDate);
        return id;
    }

    private void updateTrackerCommitmentPercentageFromRome(String scdId, FSC_Valuation_Tracker oneTracker) {
        // Update the tracker based on Rome
        logger.info("Getting deal commitment percentage from Rome");
        double commitmentPercentage = 0.0;
        String[] investranResults = dataService.getFscValuationDealFromRomeBySCDID(scdId);
        if (investranResults.length > 1) {
            String[] investranItems = investranResults[1].split("\\|");
            if (investranItems.length != 0) {
                BigDecimal lpCommitment, dealCommitment;
                dealCommitment = new BigDecimal(investranItems[6]);
                lpCommitment = new BigDecimal(investranItems[7]);
                commitmentPercentage = (lpCommitment != null && dealCommitment != null && (lpCommitment.compareTo(BigDecimal.ZERO) != 0)) ? dealCommitment.doubleValue() / lpCommitment.doubleValue() * 100 : 0.0;
                oneTracker.setDealCommitment(dealCommitment);
                oneTracker.setLPCommitment(lpCommitment);
                oneTracker.setCommitmentPercentage((float) commitmentPercentage);
                logger.info("Updating tracker table with new commitment percentage: " + commitmentPercentage);
                fsc_valuation_trackerRepository.save(oneTracker);
                logger.info("Commitment percentage successfully updated in the tracker table");
            }
        } else {
            logger.info("Record for {} is not present from Investran. Setting Commitment Percentage to 0.0.", scdId);
            oneTracker.setCommitmentPercentage((float) commitmentPercentage);
            fsc_valuation_trackerRepository.save(oneTracker);
        }
    }

    private String getPositionNameByPositionIDFromRome(String scdID, BigDecimal specificPositionID, String costFVFileName) {
        logger.info("Getting PositionName with SCDID = {} and PositionID = {} from Investran", scdID, specificPositionID);
        List<String> investranPositions = dataService.getFscValuationPositionsUnderDealFromRomeBySCDID(scdID);
        for (String investranPosition : investranPositions.subList(1, investranPositions.size())) {
            String[] investranItems = investranPosition.split("\\|");
            BigDecimal invesrtanPositionID = new BigDecimal(investranItems[2]);
            if (invesrtanPositionID.compareTo(specificPositionID) == 0) {
                return investranItems[7];
            }
        }

        logger.info("Failed to retrieve PositionName from Investran for SCDID = {} and PositionID = {} . Sending exception email to IO.", scdID, specificPositionID);
        String subject = envLevel + ": " + "Error occurred when loading Accelex FV&Cost file: " + costFVFileName;
        String exceptionMessage = "The Position Name cannot be found in Investran for SCDID = " + scdID + " and PositionID = " + specificPositionID;
        String emailBody = "<p> Hi Team, <br> <br>" +
                " Error occurred when loading Accelex FV & Cost File: " + costFVFileName + "</p> " +
                "<br> " +
                "<p>Exception message: " + exceptionMessage + "</p>";
        sendNotificationEmail(defaultEmail,"",emailBody,subject);

        logger.info("Setting PositionName with PositionID = {} to blank.", specificPositionID);
        return "";
    }

    private void updateTrackerDocoPositionIDFromRome(String scdId, FSC_Valuation_Tracker oneTracker) {
        logger.info("Getting docoPositionID from ROME");
        List<String> positionsUnderDeal = dataService.getFscValuationPositionsUnderDealFromRomeBySCDID(scdId);
        if (positionsUnderDeal.size() > 1) {
            for (String rawData : positionsUnderDeal) {
                String[] items = rawData.split("\\|");
                if (items[7].startsWith(".") && items[8].equalsIgnoreCase("True")) {
                    logger.info("Updating docoPositionID from Null to: " + items[2]);
                    oneTracker.setDocoPositionID(BigDecimal.valueOf(Integer.parseInt(items[2])));
                    fsc_valuation_trackerRepository.save(oneTracker);
                    logger.info("Updated docoPositionID in the tracker table");
                }
            }
        } else {
            logger.info("Position records not present in Investran");
            logger.info("Did not update docoPositionID in the tracker table");
        }
    }


    @Override
    public List<Accelex_CostFV> getpositionsByDealid(Integer dealID) {
        return accelexCostFVRepository.getpositionsByDealid(dealID);
    }

    private void insertHoldingsRecordForCurrentQuarterFromRome(String scdID, Date valuationDate) {
        List<String> investranPositions = dataService.getFscValuationPositionsUnderDealFromRomeBySCDID(scdID);
        for (String investranPosition : investranPositions.subList(1, investranPositions.size())) {
            String[] investranItems = investranPosition.split("\\|");
            ValuationDealPositionGLDateEffectiveDate newID = new ValuationDealPositionGLDateEffectiveDate();
            newID.DealID = Integer.valueOf(investranItems[1]);
            newID.PositionID = new BigDecimal(investranItems[2]);
            newID.ValuationDate = valuationDate;
            newID.GLDate = valuationDate;
            newID.EffectiveDate = valuationDate;

            FSC_Valuation_GP_Holdings_Total newHolding = new FSC_Valuation_GP_Holdings_Total();
            newHolding.setID(newID);
            newHolding.setSCDID(scdID);
            newHolding.setPositionName(investranItems[7]);
            newHolding.setPercentage(Float.valueOf(0));
            newHolding.setFundFairValue(new BigDecimal("0.0"));
            newHolding.setFundCost(new BigDecimal("0.0"));
            newHolding.setCppibCost(new BigDecimal("0.0"));
            newHolding.setCppibFairValue(new BigDecimal("0.0"));
            newHolding.setDataSource("Auto");
            fsc_valuation_gp_holdings_totalRepository.save(newHolding);

            if (newHolding.getPositionName().startsWith(".")) {
                // inset DotCo Positions into [qfv].[FSC_Valuation_GP_Holdings_Total]
                insertDefaultDotCoPositions(newID, scdID, valuationDate);
            }
        }
    }

    private void insertDefaultDotCoPositions(ValuationDealPositionGLDateEffectiveDate id, String scdID, Date valuationDate) {
        for (int i = 1; i <= 10; i++) {
            ValuationDealPositionGLDateEffectiveDate newID = new ValuationDealPositionGLDateEffectiveDate();
            newID.DealID = id.DealID;
            String positionID = (i != 10) ? id.PositionID.toString() + ".0" + i : id.PositionID.toString() + ".10";
            newID.PositionID = new BigDecimal(positionID);
            newID.ValuationDate =valuationDate;
            newID.GLDate = valuationDate;
            newID.EffectiveDate = valuationDate;

            FSC_Valuation_GP_Holdings_Total newHolding = new FSC_Valuation_GP_Holdings_Total();
            newHolding.setID(newID);
            newHolding.setSCDID(scdID);
            newHolding.setPositionName(componentList.get(i - 1));
            newHolding.setPercentage(Float.valueOf(0));
            newHolding.setFundFairValue(new BigDecimal("0.0"));
            newHolding.setFundCost(new BigDecimal("0.0"));
            newHolding.setCppibCost(new BigDecimal("0.0"));
            newHolding.setCppibFairValue(new BigDecimal("0.0"));
            newHolding.setDataSource("Auto");
            fsc_valuation_gp_holdings_totalRepository.save(newHolding);
        }
    }

    private void insertDefaultDotCoComponent(Date valuationDate, Integer dealID, String scdID) {
        List<Integer> piorityList = Arrays.asList(1, 2, 2, 2, 0, 3, 3, 3, 3, 3);
        List<Integer> sumSignList = Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);

        for (int i = 1; i <= 10; i++) {
            ValuationNoId valuationNoId = new ValuationNoId();
            valuationNoId.ValuationDate = valuationDate;
            valuationNoId.DealID = dealID;
            valuationNoId.No = i;

            FSC_Valuation_DotCoComponent new_Valuation_DotCoComponent = new FSC_Valuation_DotCoComponent();
            new_Valuation_DotCoComponent.setiD(valuationNoId);
            new_Valuation_DotCoComponent.setSCDID(scdID);
            new_Valuation_DotCoComponent.setComponentName(componentList.get(i - 1));
            new_Valuation_DotCoComponent.setPiority(piorityList.get(i - 1));
            new_Valuation_DotCoComponent.setSumSign(sumSignList.get(i - 1));

            fsc_Valuation_dotCoComponentRepository.save(new_Valuation_DotCoComponent);
        }
    }

    private String getLastQuarterEnd(String date) {
        // Subtract 3 months from the current month end
        LocalDate localDate = LocalDate.parse(date);
        localDate = localDate.minusMonths(3);
        localDate = localDate.withDayOfMonth(localDate.getMonth().length(localDate.isLeapYear()));
        String formattedDate = localDate.format(DATE_FORMATTER);
        return formattedDate;
    }

    private void sendNotificationEmail(String toList, String ccList, String emailBody, String subject) {
        try {
            logger.info("Sending notification email to " + toList);
            emailService.sendEmailbyBody(toList, ccList, subject, emailBody);
            logger.info("Email Sent!");
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }

    }

    private String createCostFVEmailBody(String scdId, String dealName, Map<String, Object[]> loadHistory) {
        DecimalFormat df = new DecimalFormat("#,##0.00");
        String emailBody = "<p> Hi Team, <br> <br>"
                + scdId + "-" + dealName
                + " has been changed back to 'Data Preparation In Progress' as a result of the FundCost and FundFairValue update from Accelex.</p> <br> <br>" +
                "<table style='border: 1px solid black;'>" +
                "<tr style='border: 1px solid black;'>" +
                "<th style='border: 1px solid black;'> SCDID </th>" +
                "<th style='border: 1px solid black;'> Deal Name </th>" +
                "<th style='border: 1px solid black;'> Position </th>" +
                "<th style='border: 1px solid black;'> Prev. Fair Value  </th>" +
                "<th style='border: 1px solid black;'> Prev. Cost </th>" +
                "<th style='border: 1px solid black;'> New Fair Value  </th>" +
                "<th style='border: 1px solid black;'> New Cost </th>" +
                "</tr>";
        for (Map.Entry<String, Object[]> history : loadHistory.entrySet()) {
            String positionName = history.getKey();
            Object[] valueHistory = history.getValue();
            emailBody += "<tr style='border: 1px solid black;'>" +
                    "<td style='border: 1px solid black;'> " + scdId + "</td>" +
                    "<td style='border: 1px solid black;'> " + dealName + "</td>" +
                    "<td style='border: 1px solid black;'> " + positionName + "</td>" +
                    "<td style='border: 1px solid black;'> " + df.format(valueHistory[0]) + "</td>" +
                    "<td style='border: 1px solid black;'> " + df.format(valueHistory[1]) + "</td>" +
                    "<td style='border: 1px solid black;'> " + df.format(valueHistory[2]) + "</td>" +
                    "<td style='border: 1px solid black;'> " + df.format(valueHistory[3]) + "</td>";
        }
        emailBody += "</tr> </table>";
        return emailBody;
    }

    private String createNewOrMissingPositionExceptionEmailBody(String scdId, String dealName, Map<String, Object[]> newPosition, String costFVFileName, String exceptionMessage) {
        String emailBody = "<p> Hi Team, <br> <br>"
                + scdId + "-" + dealName
                + " Error occurred when loading Accelex FV & Cost File: " + costFVFileName + "</p> " +
                "<br> " +
                "<p>Exception message: " + exceptionMessage + "</p>" +
                "<br>" +
                "<br>" +
                "<table style='border: 1px solid black;'>" +
                "<tr style='border: 1px solid black;'>" +
                "<th style='border: 1px solid black;'> SCDID </th>" +
                "<th style='border: 1px solid black;'> Deal Name </th>" +
                "<th style='border: 1px solid black;'> Position </th>" +
                "<th style='border: 1px solid black;'> PositionID  </th>" +
                "</tr>";
        for (Map.Entry<String, Object[]> history : newPosition.entrySet()) {
            String positionName = history.getKey();
            Object[] newPositionsValue = history.getValue();
            emailBody += "<tr style='border: 1px solid black;'>" +
                    "<td style='border: 1px solid black;'> " + scdId + "</td>" +
                    "<td style='border: 1px solid black;'> " + dealName + "</td>" +
                    "<td style='border: 1px solid black;'> " + positionName + "</td>" +
                    "<td style='border: 1px solid black;'> " + newPositionsValue[0] + "</td>";
        }
        emailBody += "</tr> </table>";

        emailBody += "<br>" +
                "<br>" +
                "<p>If system support is needed, please reach out " + supportEmail + "</p>";
        return emailBody;
    }


    private String getPreparerReviewerEmail(String preparer, String reviewer) {
        String toList = defaultEmail;
        FSC_Valuation_User rev = fsc_valuation_userRepository.findByUsername(reviewer);
        FSC_Valuation_User prep = fsc_valuation_userRepository.findByUsername(preparer);
        if (rev == null && prep != null) {
            toList = prep.getEmail();
        }
        if (prep == null && rev != null) {
            toList = rev.getEmail();
        }
        if (prep != null && rev != null) {
            toList = prep.getEmail() + "," + rev.getEmail();
        }
        return toList;
    }

    private Map<String, Object[]> verifyPositions(List<Accelex_CostFV> costFVList, Date valuationDate) {
        Map<String, Object[]> result = new HashMap<>();
        int dealID = costFVList.get(0).getDealID();
        List<FSC_Valuation_GP_Holdings_Total> dbHoldings = fsc_valuation_gp_holdings_totalRepository.getDealHoldings(dealID,valuationDate);
        Set<Integer> csvPositionList = new HashSet<>();

        // Create a list of all position ID from csv
        for(Accelex_CostFV costFV : costFVList) {
            csvPositionList.add(costFV.getSpecificPositionID());
        }
        // Check if CSV file contains DB positions
        for(FSC_Valuation_GP_Holdings_Total dbHolding : dbHoldings) {
            if(!csvPositionList.contains(dbHolding.getPositionId().intValue())) {
                result.put(dbHolding.getPositionName(), new Object[] {dbHolding.getPositionId().toString()});
            }
        }
        return result;
    }

}
package com.cppib.fscvaluation.service;

import com.cppib.fscvaluation.repository.*;
import com.cppib.fscvaluation.domain.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.io.FileWriter;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Date;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.*;

@Component
public class DataService {
	private final Logger logger = LoggerFactory.getLogger(DataService.class);

	public DataService() {
		logger.info("DataService");
	}

	@Value("${ROMEserver.url}")
	private String ROMEServerUrl;
	private String RomePath = "/FinancialLedgerDataService/rest/request/stream/PISubledgerDataExtract";


	@Value("${rome_dr_deals.report}")
	private String gpdc_investran_deals_folder;

	@Value("${rome_dr_positions.report}")
	private String gpdc_investran_positions_folder;


	@Autowired
	FSC_Valuation_GP_Holdings_TotalRepository  fscHoldingsTotalRepository;
	@Autowired
	AccelexCostFVService accelexCostFVService;

	@Autowired
	InvDealRepository invDealRepository;

	@Autowired
	InvPositionRepository invPositionRepository;

	@Autowired
	FscQuarterRepository fscQuarterRepository;

	@Autowired
	FSC_Valuation_TrackerRepository fscTrackerRepository;


	@Autowired
	Accelex_CostFVRepository accelex_CostFVRepository;



	// -------------- deal & position -----------------


	public long invDealCountNonDel() {
		return invDealRepository.countNonDel();
	}


	public List<InvDeal> invDealNonDel() {
		return invDealRepository.findNonDel();
	}



	public long invPositionCountNonDel() {
		return invPositionRepository.countNonDel();
	}



	public List<InvPosition> invPositionNonDel() {
		return invPositionRepository.findNonDel();
	}
	public List<Integer> findpositionidNonDel() {
		return invPositionRepository.findpositionidNonDel();
	}

	public List<InvPosition> invDealPositions(int dealId) {

		return invPositionRepository.getPositionsByDealNonDel(dealId);
	}

	public List<Integer> getUnmappedInfo(Date ValuationDate) {
		return accelex_CostFVRepository.getunMappedIds(ValuationDate);
	}

	// ---------- activity & tracker -----------

	public FscQuarter getActiveQuarter() {
		logger.info("inside ");
		List<FscQuarter> list = fscQuarterRepository.findActive();
		logger.info("list is " + list.size() + list.get(0));
		if (list != null && list.size() > 0)
			return list.get(0);
		return null;
	}



	public List<FSC_Valuation_Tracker> getTrackers(String quarter) {
		logger.info("TRACKER");
		return fscTrackerRepository.getTrackersByQuarter(Date.valueOf(quarter));
	}


	private static boolean equal(String s1, String s2) {
		if (s1 == null) return s2 == null;
		return s1.equals(s2);
	}

	private static boolean equal(BigDecimal d1, BigDecimal d2) {
		if (d1 == null) return d2 == null;
		return d2 != null && d1.compareTo(d2) == 0;
	}


	public String[] getDealsFromRome() {

		RestTemplate restTemplate = new RestTemplate();

		String url = String.format("%s?query=<Query><DataSourceId>[WebServiceReports].[%s]</DataSourceId><Parameters></Parameters></Query>&delimiter=|&outputDateFormat=yyyy-MM-dd",
				ROMEServerUrl + RomePath, gpdc_investran_deals_folder);
		logger.info("url" + url);
		String result = restTemplate.getForObject(url, String.class);

		int start = result.indexOf("START-OF-DATA");
		int end = result.indexOf("END-OF-DATA");
		logger.info(String.format("%d - %d", start, end));
		if (start + 15 > end - 2) {
			logger.info(result);
			return null;
		}
		return result.substring(start + 15, end - 2).split("\r\n");
	}


	public String[] getFscValuationDealFromRomeBySCDID(String scdid) {
		String result = "";
		int start = 0, end = 0;
		try {
			String parameters = "<Parameter name=\"SCDID\">" + scdid + "</Parameter>";
			RestTemplate restTemplate = new RestTemplate();
			String url = ROMEServerUrl + RomePath + "?query=<Query><DataSourceId>[WebServiceReports].[FSC_Valuation_Deals_Static_Sheet]</DataSourceId><Parameters>" +
					parameters + "</Parameters></Query>&delimiter=|&outputDateFormat=yyyy-MM-dd";
			logger.info(url);
			result = restTemplate.getForObject(url, String.class);
			start = result.indexOf("START-OF-DATA");
			end = result.indexOf("END-OF-DATA");
			logger.info(String.format("%d - %d", start, end));
			if (start + 15 > end - 2) {
				logger.info(result);
				return null;
			}
		} catch (Exception e) {
			logger.info(e.getMessage(), e);
		}
		return result.substring(start+15, end-2).split("\r\n");
	}

	public List<String> getFscValuationPositionsUnderDealFromRomeBySCDID(String scdid) {
		List<String> results = new ArrayList<String>();
		try {
			String parameters = "<Parameter name=\"SCDID\">" + scdid + "</Parameter>";
			RestTemplate restTemplate = new RestTemplate();
			String url = ROMEServerUrl + RomePath + "?query=<Query><DataSourceId>[WebServiceReports].[FSC_Valuation_Positions_Under_Deal]</DataSourceId><Parameters>" +
					parameters + "</Parameters></Query>&delimiter=|&outputDateFormat=yyyy-MM-dd";
			logger.info(url);
			String result = restTemplate.getForObject(url, String.class);

			String[] resultlines = result.split("\r\n");
			boolean started = false;
			for( String line : resultlines) {
				if (line.startsWith("START-OF-DATA"))
					started = true;
				else if (line.startsWith("END-OF-DATA"))
					break;
				else if (started) results.add(line);
			}
		} catch (Exception e) {
			logger.info(e.getMessage(), e);
		}
		return results.isEmpty() ? null : results;
	}

	// Repeatable read will ensure that if two concurrent transactions read and change the same record more or less concurrently,
	// only one of them will succeed.
	@Transactional(isolation = Isolation.REPEATABLE_READ)
	public List<String> doInvestranSync(String userID) throws Exception {

		logger.info("sync deals start ...");

		logger.info("\tgetDealsFromRome");
		String deals[] = getDealsFromRome();
		if (deals == null || deals.length == 0)
			throw new Exception("getDealsFromRome - no data");
		logger.info("Total " + deals.length + " deals");
		if (!deals[0].equals("Deal ID|Deal Name|SCD ID|Deal Currency"))
			throw new Exception("getDealsFromRome - unexpected header");

		Date current_date = new Date(System.currentTimeMillis());
		Map<Integer, InvDeal> rome_deals = new HashMap<Integer, InvDeal>();

		for (int i = 1; i < deals.length; i++) {
			String[] items = deals[i].split("\\|");
			InvDeal deal = new InvDeal();
			deal.setDealId(Integer.parseInt(items[0]));
			deal.setName(items[1]);
			// deal.setFamilyName(items[2]);
			// deal.setPrivate1("True".equals(items[3]));
			deal.setScdId(items[2]);
			deal.setCurrency(items[3]);
			deal.setChangedDate(current_date);
			deal.setuserID(userID);
			rome_deals.put(deal.getDealId(), deal);
		}

		List<InvDeal> db_deals = invDealRepository.findAll();

		List<Integer> list_del = new ArrayList<Integer>();
		List<Integer> list_chg = new ArrayList<Integer>();
		List<Integer> list_same = new ArrayList<Integer>();
		List<InvDeal> list_add_deal = new ArrayList<InvDeal>();
		List<Integer> list_del_position = new ArrayList<Integer>();


		for (InvDeal deal : db_deals) {
			int dealId = deal.getDealId();
			if (!rome_deals.containsKey(dealId)) {
				if (!equal(deal.getStatus(), "D")) {
					deal.setStatus("D");
					deal.setChangedDate(current_date);
					list_del.add(dealId);
					logger.info(String.format("[%d] to be deleted: %s", dealId, deal.getName()));
					invDealRepository.save(deal);
					List<InvPosition> pos = invPositionRepository.getPositionsByDeal(dealId);
					for (InvPosition position : pos) {
						int positionId = position.getspecificPositionId();
						if (!equal(position.getStatus(), "D")) {
							position.setStatus("D");
							position.setChangedDate(current_date);
							list_del_position.add(positionId);
							logger.info(String.format("[%d] to be deleted: %s", positionId, position.getPositionName()));
							invPositionRepository.save(position);
						}
					}
				}
				continue;
			}

			InvDeal rome_deal = rome_deals.get(dealId);
			boolean changes = false;
			if (!equal(deal.getName(), rome_deal.getName())) {
				logger.info(String.format("[%d] name to be changed: %s <== %s", dealId, deal.getName(), rome_deal.getName()));
				deal.setName(rome_deal.getName());
				changes = true;
			}

			/*if (!equal(deal.getFamilyName(), rome_deal.getFamilyName())) {
				logger.info(String.format("[%d] family name to be changed: %s <== %s",
						dealId, deal.getFamilyName(), rome_deal.getFamilyName()));
				deal.setFamilyName(rome_deal.getFamilyName());
				changes = true;
			}*/

			if (!equal(deal.getScdId(), rome_deal.getScdId())) {
				logger.info(String.format("[%d] Scd-Id to be changed: %s <== %s",
						dealId, deal.getScdId(), rome_deal.getScdId()));
				deal.setScdId(rome_deal.getScdId());
				changes = true;
			}

			/*if (deal.getPrivate1() != rome_deal.getPrivate1()) {
				logger.info(String.format("[%d] Private to be changed: %s <== %s",
						dealId, deal.getPrivate1(), rome_deal.getPrivate1()));
				deal.setPrivate1(rome_deal.getPrivate1());
				changes = true;
			}*/
			if (!equal(deal.getCurrency(), rome_deal.getCurrency())) {
				logger.info(String.format("[%d] Currency to be changed: %s <== %s",
						dealId, deal.getCurrency(), rome_deal.getCurrency()));
				deal.setCurrency(rome_deal.getCurrency());
				changes = true;
			}
			if (equal(deal.getStatus(), "D")) {
				logger.info(String.format("[%d] Status to be changed: '.' <== '%s'", dealId, deal.getStatus()));
				deal.setStatus(".");
				changes = true;
			}

			if (changes) {
				list_chg.add(dealId);
				deal.setChangedDate(current_date);
				invDealRepository.save(deal);
			} else
				list_same.add(dealId);
		}

		for (int x : rome_deals.keySet()) {
			if (!list_del.contains(x) && !list_chg.contains(x) && !list_same.contains(x)) {
				rome_deals.get(x).setStatus(" ");
				rome_deals.get(x).setChangedDate(current_date);
				list_add_deal.add(rome_deals.get(x));
			}
		}
//		if (list_add_deal.size() > 0)
//			invDealRepository.save(list_add_deal);
		if (list_add_deal.size() > 0) {
			for (InvDeal invDeal : list_add_deal) {
				invDealRepository.save(invDeal);
			}
		}

		logger.info("#list_chg: " + list_chg.size());
		logger.info("#list_del: " + list_del.size());
		logger.info("#list_add: " + list_add_deal.size());
		logger.info("#list_same: " + list_same.size());

		List<String> msg = new ArrayList<String>();
		if (list_add_deal.size() > 0)
			msg.add(String.format("%d deals added", list_add_deal.size()));
		if (list_del.size() > 0)
			msg.add(String.format("%d deals removed", list_del.size()));
		if (list_chg.size() > 0)
			msg.add(String.format("%d deals updated", list_chg.size()));

		if (msg.size() == 0)
			msg.add("No deal changes");

		logger.info("sync positions start ...");

		String pos[] = getPositionsFromRome();
		if (pos == null || pos.length == 0)
			throw new Exception("getPositionsFromRome - no data");
		logger.info("Total " + pos.length + " positions");
		if (!pos[0].equals("Position ID|Deal ID|Position"))
			throw new Exception("getPositionsFromRome - unexpected header");

		Map<Integer, InvPosition> rome_positions = new HashMap<Integer, InvPosition>();

		for (int i = 1; i < pos.length; i++) {
			String[] items = pos[i].split("\\|");
			// if (rome_deals.containsKey(Integer.parseInt(items[1]))) {
				InvPosition position = new InvPosition();
				position.setspecificPositionId(Integer.parseInt(items[0]));
				position.setDealId(Integer.parseInt(items[1]));
				position.setPositionName(items[2]);
				rome_positions.put(position.getspecificPositionId(), position);
			/*}
			continue;
*/		}
		logger.info("Total positions:"+ rome_positions.size());

		List<InvPosition> db_positions = invPositionRepository.findAll();

		list_chg = new ArrayList<Integer>();
		list_same = new ArrayList<Integer>();
		List<InvPosition> list_add_pos = new ArrayList<InvPosition>();

		for (InvPosition position : db_positions) {
			int positionId = position.getspecificPositionId();
			if (!rome_positions.containsKey(positionId)) {
				if (!equal(position.getStatus(), "D")) {
					position.setStatus("D");
					position.setChangedDate(current_date);
					list_del_position.add(positionId);
					logger.info(String.format("[%d] to be deleted: %s", positionId, position.getPositionName()));
					invPositionRepository.save(position);
				}
				continue;
			}

			InvPosition rome_position = rome_positions.get(positionId);
			boolean changes = false;
			if (!equal(position.getPositionName(), rome_position.getPositionName())) {
				logger.info(String.format("[%d] name to be changed: %s <== %s",
						positionId, position.getPositionName(), rome_position.getPositionName()));
				position.setPositionName(rome_position.getPositionName());
				changes = true;
			}

			if (!position.getDealId().equals(rome_position.getDealId())) {
				logger.info(String.format("[%d] deal id to be changed: %d <== %d",
						positionId, position.getDealId(), rome_position.getDealId()));
				position.setDealId(rome_position.getDealId());
				changes = true;
			}

			if (equal(position.getStatus(), "D")) {
				logger.info(String.format("[%d] Status to be changed: '.' <== '%s'", positionId, position.getStatus()));
				position.setStatus(".");
				changes = true;
			}

			if (changes) {
				list_chg.add(positionId);
				position.setChangedDate(current_date);
				invPositionRepository.save(position);
			} else
				list_same.add(positionId);
		}

		for (int x : rome_positions.keySet()) {
			if (!list_del_position.contains(x) && !list_chg.contains(x) && !list_same.contains(x)) {
				rome_positions.get(x).setChangedDate(current_date);
				rome_positions.get(x).setStatus(" ");
				list_add_pos.add(rome_positions.get(x));
			}
		}
//		if (list_add_pos.size() > 0)
//			invPositionRepository.save(list_add_pos);
		if (list_add_pos.size() > 0) {
			for (InvPosition invPosition : list_add_pos) {
				invPositionRepository.save(invPosition);
			}
		}

		if (list_add_pos.size() > 0)
			msg.add(String.format("%d positions added", list_add_pos.size()));

		if (list_del_position.size() > 0)
			msg.add(String.format("%d positions removed", list_del.size()));

		if (list_chg.size() > 0)
			msg.add(String.format("%d positions updated", list_chg.size()));

		if (list_add_pos.size() == 0 && list_del.size() == 0 && list_chg.size() == 0)
			msg.add("No position changes");

		logger.info("sync end.");
		return msg;
	}

	public String[] getPositionsFromRome() {
		RestTemplate restTemplate = new RestTemplate();
		String url = String.format("%s?query=<Query><DataSourceId>[WebServiceReports].[%s]</DataSourceId><Parameters></Parameters></Query>&delimiter=|&outputDateFormat=yyyy-MM-dd",
		ROMEServerUrl+RomePath, gpdc_investran_positions_folder);
		String result = restTemplate.getForObject(url, String.class);
		int start = result.indexOf("START-OF-DATA");
		int end = result.indexOf("END-OF-DATA");
		logger.info(String.format("%d - %d", start, end));
		return result.substring(start + 15, end - 2).split("\r\n");

	}



	public List<FSC_Valuation_GP_Holdings_Total> getValuationDataValue(int dealid, String periodend) {
		Date date = null;
		try {
			date = new Date(new SimpleDateFormat("yyyy-MM-dd").parse(periodend).getTime());
		} catch (Exception ex) {
			logger.warn(ex.getMessage());
			return null;
		}
		return fscHoldingsTotalRepository.getDealHoldings(dealid, date);
	}

	private static final int ValuationMatchStatus_NotAllMapped = -1;
	private static final int ValuationMatchStatus_Equal = 0;
	private static final int ValuationMatchStatus_NewOrUpdated = 1;

	public int[] valuationMatches(String valuationQuarter, List<Integer> fund_list) {
		logger.info("inside "+ valuationQuarter);

		Date valuation_date;
		try {
			valuation_date = new Date(new SimpleDateFormat("yyyy-MM-dd").parse(valuationQuarter).getTime());
		} catch (Exception ex) {
			logger.warn(ex.getMessage());
			return null;
		}
		//Map<Integer, Integer> unmapped = new HashMap<Integer, Integer>();
		List<Integer> unmappedeals= getUnmappedInfo(valuation_date);
		//logger.info("ddd"+ unmappedeals.get(0));
		// fund_list.remove(unmappedeals);
		/*for (Object[] x : getUnmappedInfo(valuation_date)) {
			int fundid = (Integer) x[0];
			//int num = (Integer) x[1];
			//if (num > 0) unmapped.put(fundid, num);
		}
*/
		Map<Integer, Boolean> matches = new HashMap<Integer, Boolean>();
		for (Integer x : fund_list) {
			matches.put(x, true);
		}



		Map<Integer, Integer> position2fund = new HashMap<Integer, Integer>();
		/*Map<Integer, BigDecimal> target_cost = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> target_fv = new HashMap<Integer, BigDecimal>();
		*/
		/*Map<String, Integer> fund_company_position_map = new HashMap<String, Integer>();
		for (Accelex_CostFV_ID map : accelex_CostFVRepository.findAllmapping()) {
			int fundId = map.getDealID();
			if (!matches.containsKey(fundId)) continue;				// GPDC-50
			int positionId = map.getSpecificPositionID();
			// String fund_company = fundId+"."+map.getCompanyId();
			// fund_company_position_map.put(fund_company, positionId);
			if (!position2fund.containsKey(positionId)) position2fund.put(positionId, fundId);
			// fix issue of cost & fv are null in iLevel
			if (!(target_cost.containsKey(positionId))) target_cost.put(positionId, new BigDecimal(0)); 
			if (!(target_fv.containsKey(positionId))) target_fv.put(positionId, new BigDecimal(0)); 
		}

		for (RawData data : rawDataRepository.getAllCostAndFV(ilevel_date, cost_id, fv_id)) {
			int fundid = data.getFundId();
			if (unmapped!=null && unmapped.containsKey(fundid)) continue;
			String fund_company = fundid+"."+data.getAssetId();
			if (!(fund_company_position_map.containsKey(fund_company))) continue;		// skip removed fund-company
			int positionId = fund_company_position_map.get(fund_company);
			BigDecimal value = data.getNumValue().setScale(2, BigDecimal.ROUND_DOWN);	// GPDC-50
			/////////////
			if (data.getDataItemId().equals(cost_id)) {
				if (target_cost.containsKey(positionId)) value = value.add(target_cost.get(positionId));
				target_cost.put(positionId, value);
			}
			else if (data.getDataItemId().equals(fv_id)) {
				if (target_fv.containsKey(positionId)) value = value.add(target_fv.get(positionId));
				target_fv.put(positionId, value);
			}
		}*/

		Map<Integer, BigDecimal> target_cost = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> target_fv = new HashMap<Integer, BigDecimal>();
		BigDecimal zero = new BigDecimal(0);
		for (Accelex_CostFV d : accelexCostFVService.getdealsByValuationdate(valuation_date)) {
			int fundId = d.getDealID();
			if (!matches.containsKey(fundId)) continue;                // GPDC-50
			int positionId = d.getSpecificPositionID().intValue();
			if (!position2fund.containsKey(positionId)) position2fund.put(positionId, fundId);
			target_cost.put(positionId, d.getFundCost() == null ? zero : d.getFundCost());
			target_fv.put(positionId, d.getFundFairValue() == null ? zero : d.getFundFairValue());
		}



		List<Integer> investran_positions = findpositionidNonDel();
		Map<Integer, BigDecimal> valuation_cost = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> valuation_fv = new HashMap<Integer, BigDecimal>();
		for (FSC_Valuation_GP_Holdings_Total d : fscHoldingsTotalRepository.getAllHoldings(valuation_date)) {
			int fundId = d.getID().DealID;
			int positionId = d.getPositionId().intValue();
			if(!investran_positions.contains(positionId)) continue;
			if (!position2fund.containsKey(positionId)) position2fund.put(positionId, fundId);
			valuation_cost.put(positionId, d.getFundCost() == null ? zero : d.getFundCost());
			valuation_fv.put(positionId, d.getFundFairValue() == null ? zero : d.getFundFairValue());
		}

		//System.out.println(target_cost);
		//System.out.println(target_fv);

		for (int position : target_cost.keySet()) {        // all company cost must have same position cost but not necessary all position has a company cost
			if (valuation_cost.containsKey(position) && valuation_cost.get(position).compareTo(target_cost.get(position)) == 0)
				continue;
			else{
				if (!valuation_cost.containsKey(position) && (target_cost.get(position)).compareTo(BigDecimal.ZERO) ==0)
				continue;
			}
			int fundId = position2fund.get(position);
			matches.put(fundId, false);
		}

		for (int position : target_fv.keySet()) {        // all company fv must have same position fv but not necessary all position has a company fv
			if (valuation_fv.containsKey(position) && valuation_fv.get(position).compareTo(target_fv.get(position)) == 0)
				continue;
			else{
				if (!valuation_fv.containsKey(position) && (target_fv.get(position)).compareTo(BigDecimal.ZERO) ==0)
					continue;
			}
			int fundId = position2fund.get(position);
			matches.put(fundId, false);
		}

		for (int position : valuation_cost.keySet()) {        // all company cost must have same position cost but not necessary all position has a company cost
			if (target_cost.containsKey(position) && target_cost.get(position).compareTo(valuation_cost.get(position)) == 0)
				continue;
			else{
				if (!target_cost.containsKey(position) && (valuation_cost.get(position)).compareTo(BigDecimal.ZERO) ==0)
					continue;
			}
			int fundId = position2fund.get(position);
			matches.put(fundId, false);
		}

		for (int position : valuation_fv.keySet()) {        // all company fv must have same position fv but not necessary all position has a company fv
			if (target_fv.containsKey(position) && target_fv.get(position).compareTo(valuation_fv.get(position)) == 0)
				continue;
			else{
				if (!target_fv.containsKey(position) && (valuation_fv.get(position)).compareTo(BigDecimal.ZERO) ==0)
					continue;
			}
			int fundId = position2fund.get(position);
			matches.put(fundId, false);
		}

		int num = fund_list.size();
		int[] result = new int[num];
		for (int i = 0; i < num; i++) {
			int fundId = fund_list.get(i);
			if (unmappedeals.contains(fundId)) result[i] = ValuationMatchStatus_NotAllMapped;
			else result[i] = matches.get(fundId) ? ValuationMatchStatus_Equal : ValuationMatchStatus_NewOrUpdated;
		}
		return result;
	}
}

    package com.cppib.fscvaluation.service;

import com.cppib.fscvaluation.domain.Accelex_CostFV;

import java.sql.Date;
import java.util.List;

public interface AccelexCostFVService {
    List<Accelex_CostFV> findAll();

    List<Accelex_CostFV> getdealsByValuationdate(Date valuationquarter);
    Accelex_CostFV getAccelexCostFV(Date valuationDate, Integer dealID, Integer specificPositionID);

    void processAccelexCostFv(List<Accelex_CostFV> fvCosts, String costFVFileName);

    List<Accelex_CostFV> getpositionsByDealid(Integer dealID);


}
