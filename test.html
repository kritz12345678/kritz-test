export class normalstrategyChartoptions implements stackedColumnChartOptions {
  linkedChart?: any;

  constructor(categories: string[], seriesData: SeriesOptionsType[], chartType: string) {
    this.categories = categories;
    this.series = seriesData;

    if (chartType === 'normal') {
      this.tooltip = {
        enabled: true,
        headerFormat: '<b>{point.x}</b><br/>',
        formatter: function () {
          const self = this as any;
          return '<span style="color:' + self.point.color + '">' + self.series.name + ': $' + (self.y / 1000000000).toFixed(1) + 'B<br/>Total: $' + (self.total / 1000000000).toFixed(1) + 'B';
        }
      };

      this.plotOptions = {
        ...defaultNormalPlotOptions,
        column: {
          stacking: 'normal',
          dataLabels: {
            enabled: false,
            formatter: function () {
              return '$' + ((this as any).y / 1000000000).toFixed(1);
            },
            style: {
              color: '#636D73',
              textAlign: 'center',
              fontFamily: 'Roboto',
              fontSize: '14px',
              fontWeight: '600',
              lineHeight: '16px'
            }
          },
          pointWidth: 90,
        }
      };

      this.chartstyle = {
        height: '330',
        marginTop: 80,
        width: '700'
      };

      this.yAxis = [{
        labels: {
          enabled: true,
          step: 0,
          formatter: function () {
            return (this as any).value / 1000000000 + 'B'; // Dividing by 1 billion to convert to billions
          }
        },
        stackLabels: {
          enabled: true,
          formatter: function () {
            return '$' + (this as any).total / 1000000000;
          }
        },
        gridLineWidth: 0,
        lineWidth: 0,
        title: {
          text: ''
        }
      }];

      this.legend = {
        ...defaultLegendOptions,
        itemClick: function (event: any) {
          if (this.linkedChart) {
            const seriesIndex = event.target.index;
            const series = this.linkedChart.series[seriesIndex];
            if (series) {
              series.visible ? series.hide() : series.show();
            }
          }
        }
      };
    } else if (chartType === 'percentage') {
      this.tooltip = {
        enabled: true,
        headerFormat: '<b>{point.x}</b><br/>',
        formatter: function () {
          const self = this as any;
          return '<span style="color:' + self.point.color + '">' + self.series.name + '</span>: <b>' + Math.round((self.y / self.total) * 100) + '%</b><br/>';
        }
      };

      this.plotOptions = {
        ...defaultPercentPlotOptions,
        column: {
          stacking: 'percent',
          dataLabels: {
            enabled: false,
            formatter: function () {
              const self = this as any;
              return Math.round((self.y / self.total) * 100) + '%';
            },
            style: {
              color: '#636D73',
              textAlign: 'center',
              fontFamily: 'Roboto',
              fontSize: '14px',
              fontWeight: '600',
              lineHeight: '16px'
            }
          },
          pointWidth: 90,
        }
      };

      this.chartstyle = {
        height: '290',
        marginTop: 30,
        width: '700'
      };

      this.yAxis = [{
        labels: {
          enabled: true
        },
        gridLineWidth: 0,
        lineWidth: 0,
        max: 100, // Setting the max value of the y-axis to 100
        title: {
          text: ''
        }
      }];

      this.legend = {
        enabled: false
      };
    } else {
      this.tooltip = defaultToolTip;
      this.plotOptions = defaultNormalPlotOptions;
      this.chartstyle = defaultchartstyle;
      this.yAxis = defaultyAxis;
      this.legend = defaultLegendOptions;
    }
  }

  categories: string[];
  plotOptions: PlotOptions | undefined;
  series: SeriesOptionsType[];
  tooltip: TooltipOptions;
  chartstyle: chartstyle;
  yAxis: yAxisOptions[];
  legend: LegendOptions;
}
